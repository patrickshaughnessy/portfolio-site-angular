'use strict';

angular
  .module('app')
  .controller('blogCtrl', function($timeout, $scope, $location, $anchorScroll){
    $scope.posts = posts.reverse();

    $timeout(function(){
      $scope.loaded = true;
    }, 1500)



    $scope.goToPost = function(id) {
       $location.hash(id);
       $anchorScroll();
    }

  });
var posts = [{"title":"Integrating A Blog On A Static Site Built With Angular And Angular UI Router","id":"Integrating_A_Blog_On_A_Static_Site_Built_With_Angular_And_Angular_UI_Router","date":"01-15-2016","tags":["blog","Angular","Javascript"],"image":"working-on-computer.jpeg","body":"<p>There are a ton of open source blog generators for devs out there: Ghost, Hexo, Jekyll, Wintersmith, Metalsmith (<a href=\"http://sixrevisions.com/tools/open-source-blogging-platforms-for-developers/\" title=\"Open Source Blogging Platforms For Developers\">this post</a> has a nice write-up on a few). But when I set out to make my personal site, I ran into a glaring problem with all of them.</p>\n<p>The goal was to make a little portfolio site - a landing page, a page to showcase and link to my work, and an integrated blog. Pretty simple, right? I thought so too, until I started playing around with these tools. After much frustration and tinkering, I realized that none of them had a simple, out-of-the-box solution to create different pages or views. Apparently, you can either have a blog or a site, but you can&#39;t have both.</p>\n<p>Well, that just wasn&#39;t going to work for me =).</p>\n<h3 id=\"if-it-doesn-t-exist-make-it\">If It Doesn&#39;t Exist, Make It</h3>\n<p>I knew what I needed to do, so it was just a matter of putting the pieces together correctly in order to make it work. Initially, I tried messing around with <a href=\"https://hexo.io/\" title=\"Hexo\">Hexo</a>. But even after diving into the config settings, I couldn&#39;t find a way to generate even a simple home page without the blog.</p>\n<p>Then I thought <a href=\"http://www.metalsmith.io/\" title=\"metalsmith\">metalsmith</a> was going to work out. You basically make a build file that compiles all your files into a nice little static package. Unfortunately, the learning curve was a bit too steep on this one and I could never quite get past the most basic of basic tutorials (although <a href=\"https://azurelogic.com/posts/building-a-blog-with-metalsmith/\" title=\"Building a blog with Metalsmith\">this tutorial by Rob Ribeiro</a> was super helpful and at least got me started).</p>\n<p>By this point, I realized I needed to do one of two things. Either find a way to:</p>\n<ol>\n<li>Generate my views with one of these blog generators, <em>OR</em></li>\n<li>Compile the markdown to HTML and inject it into my site before deploying.</li>\n</ol>\n<p>I was out of ideas on option 1, so it was on to option 2.</p>\n<h3 id=\"the-setup\">The Setup</h3>\n<p>You can find all the code for this on <a href=\"https://github.com/patrickshaughnessy/Example-Portfolio-Site-With-Blog\" title=\"my github repo\">my github repo</a>. Feel free to clone it down and follow along or use it as a template.</p>\n<p>Basically I started with a pretty simple setup - just angular and angular-ui-router to handle my views and bootstrap for styling. Theres a &#39;posts&#39; folder with a few markdown files, but they&#39;re not showing up in our blog just yet.</p>\n<p>What we need to do is take those markdown files, preserve the front matter as data, render the body to HTML, and make it available to our angular app. In other words, we need a build script. In your terminal:</p>\n<pre><code><span class=\"hljs-selector-tag\">touch</span> <span class=\"hljs-selector-tag\">build</span><span class=\"hljs-selector-class\">.js</span>\n</code></pre><h3 id=\"node-time-\">Node Time!</h3>\n<p>We&#39;ll need a few dependencies to make our build script run properly, so let&#39;s add those now. Do an</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> init\n</code></pre><p>and follow the prompts to initialize a package.json file in your directory. For this project, we&#39;ll need to parse our markdown and concat some files together, so:</p>\n<pre><code>npm <span class=\"hljs-selector-tag\">i</span> -S concat-files markdown-parse\n</code></pre><p>Ok now we&#39;re ready to make our build script!</p>\n<h3 id=\"the-build\">The Build</h3>\n<p>Let&#39;s start out by requiring our dependencies. In your build.js:</p>\n<pre><code><span class=\"hljs-meta\">'use strict'</span>;\n\n<span class=\"hljs-keyword\">var</span> concat = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'concat-files'</span>);\n<span class=\"hljs-keyword\">var</span> parser = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'markdown-parse'</span>);\n<span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">var</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n</code></pre><p>Great! Now the first thing we want to do is grab all those markdown files from our posts directory so they&#39;re available to the parser. Then we&#39;ll want to iterate over each one, creating a new post object that we can use in our angular app later.</p>\n<pre><code>fs.readdir('./posts/', function(err, files){\n    <span class=\"hljs-keyword\">if</span> (err) throw err;\n    <span class=\"hljs-keyword\">var</span> posts = [];\n    files.forEach(function(file){\n        <span class=\"hljs-keyword\">var</span> content = (fs.readFileSync(__dirname + `/posts/${file}`, 'utf8'));\n\n    parser(content, function(err, <span class=\"hljs-literal\">result</span>){\n        <span class=\"hljs-keyword\">var</span> newPost = {};\n        newPost.title = <span class=\"hljs-literal\">result</span>.attributes.title;\n        newPost.id = <span class=\"hljs-literal\">result</span>.attributes.id;\n        newPost.date = <span class=\"hljs-literal\">result</span>.attributes.date;\n        newPost.tags = <span class=\"hljs-literal\">result</span>.attributes.tags || [];\n        newPost.body = <span class=\"hljs-literal\">result</span>.html.toString();\n\n        posts.push(newPost);\n    })\n});\n</code></pre><p>It&#39;s worth noting here that this gives you complete control over the data you make available to your blog component. Here I&#39;ve only included things like the title, date, and tags. But you could easily expand this to include just about any meta data you want.</p>\n<p>Next, we&#39;ll write a temporary file to hold the posts data. We can assign it to a variable &#39;data&#39; to make it available to our angular app later.</p>\n<pre><code><span class=\"hljs-title\">var</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> = `var posts = ${<span class=\"hljs-type\">JSON</span>.<span class=\"hljs-title\">stringify</span>(<span class=\"hljs-title\">posts</span>)}`</span>\n<span class=\"hljs-title\">fs</span>.writeFileSync('./posts.js', <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>);</span>\n</code></pre><p>And finally, let&#39;s combine our blog component controller with our newly minted post data. We should also remove that temporary posts file to keep our directory nice and clean.</p>\n<pre><code>concat([\n    <span class=\"hljs-string\">'./controllers/blogCtrl.js'</span>,\n    <span class=\"hljs-string\">'./posts.js'</span>\n], path.resolve(__dirname, <span class=\"hljs-string\">'./controllers/blogCtrlCompiled.js'</span>), function(<span class=\"hljs-keyword\">err</span>){\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">err</span>) throw <span class=\"hljs-keyword\">err</span>\n    console.log(<span class=\"hljs-string\">'All posts compiled successfully!'</span>)<span class=\"hljs-comment\">;</span>\n    fs.unlinkSync(<span class=\"hljs-string\">'./posts.js'</span>)\n})<span class=\"hljs-comment\">;</span>\n</code></pre><p>Now we can run our build.js file in node, and it will create a new file called blogCtrlCompiled.js in our controllers directory. If you take a peek inside that compiled controller file you&#39;ll see that our data has been added to the bottom and is now accessible to the controller.</p>\n<h3 id=\"setting-up-the-blog-component\">Setting Up The Blog Component</h3>\n<p>With the tricky part of injecting our posts into the app finished, we can move on to getting the blog set up and styled to our liking. I find a custom directive helpful in this situation. We can set it up once, and then just ng-repeat over each post and populate them automatically.</p>\n<p>So in our templates/blog.html, let&#39;s change the &#39;posts go here&#39; to:</p>\n<pre><code>&lt;<span class=\"hljs-keyword\">div</span> class=<span class=\"hljs-string\">\"col-xs-12\"</span> ng-<span class=\"hljs-keyword\">repeat</span>=<span class=\"hljs-string\">\"post in posts\"</span>&gt;\n    &lt;blog-<span class=\"hljs-built_in\">post</span> info={{<span class=\"hljs-built_in\">post</span>}}&gt;&lt;/blog-<span class=\"hljs-built_in\">post</span>&gt;\n&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre><p>And create a blogPost directive - blogPost.js</p>\n<pre><code><span class=\"hljs-meta\">'use strict'</span>;\n\nangular.module(<span class=\"hljs-string\">'app'</span>).directive(<span class=\"hljs-string\">'blogPost'</span>, blogPost);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">blogPost</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> {\n        restrict: <span class=\"hljs-string\">\"AE\"</span>,\n        templateUrl: <span class=\"hljs-string\">\"directives/blogPost.html\"</span>,\n        scope: {\n            info: <span class=\"hljs-string\">\"@\"</span>\n        },\n        controller: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">$scope</span>) </span>{\n<span class=\"hljs-meta\">            'use strict'</span>;\n            $scope.post = <span class=\"hljs-built_in\">JSON</span>.parse($scope.info);\n        }\n    };\n};\n</code></pre><p>and our template html - blogPost.html</p>\n<pre><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"postTitle\"</span> <span class=\"hljs-attr\">id</span>=</span></span><span class=\"hljs-template-variable\">{{post.id}}</span><span class=\"xml\"><span class=\"hljs-tag\">&gt;</span></span><span class=\"hljs-template-variable\">{{post.title}}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h6</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"postDate\"</span>&gt;</span></span><span class=\"hljs-template-variable\">{{post.date}}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h6</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ng-bind-html</span>=<span class=\"hljs-string\">\"post.body\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre><p>Note that ng-bind-html requires the angular $sanitize service to be available to your app. You&#39;ll need to add the cdn link in a script to your index.html and inject it in the app.js file as well. Of course, don&#39;t forget to link up your new directive in your index.html too.</p>\n<p>And that&#39;s about it! Just run build.js before serving it up on localhost or deploying to gh-pages or wherever.</p>\n<h3 id=\"final-thoughts\">Final Thoughts</h3>\n<p>At first I was overwhelmed at the thought of making my own blog component. Plenty of people who&#39;ve been doing this longer than I have made all these cool blog generating tools - it&#39;s probably really hard. And it was totally frustrating at first digging through the config files on each of them, trying to figure out how they worked. But a little persistence goes a long way, and I&#39;m super satisfied with the way it turned out. Now I&#39;ve got a fully integrated blog on a single-page static site, and I can customize it however I want without worrying about messing up some &#39;magic&#39; buried in some node module somewhere in the npm package.</p>\n<p>What do you think? Any ideas on how I can improve this thing or did you do it a different way? Let me know!</p>\n"},{"title":"Your First Flux Flow, Demystified","id":"Your_First_Flux_Flow,_Demystified","date":"01-24-2016","tags":["Flux","React","Javascript"],"image":"water-flow.jpg","body":"<p>Last week at <a href=\"https://codinghouse.co/#!home\" title=\"Coding House\">Coding House</a>, some of us chose to create a web app using React. Our group made a forum for prospective or current students and alumni of dev bootcamps to ask questions and share their experiences. Check it out <a href=\"https://reddit-for-devcamps.herokuapp.com/\" title=\"Link To DevCampFire\">here</a>.</p>\n<p>Listening to some of the frustrations from the other teams as well as working through our own issues during the project, I thought that doing a little Flux flow tutorial would be beneficial. I&#39;ll use Robbie McLellan&#39;s SwordOfTheNinja template to start out, which you can find <a href=\"https://github.com/rlm14/SwordOfTheNinja\" title=\"Sword Of The Ninja Link\">here</a>. I like to use it whenever I start React projects because it has all the essentials for creating a full stack React app like babel and jspm without any unnecessary sugar. Make sure to give him a star if you use it in your projects!</p>\n<h3 id=\"getting-started\">Getting Started</h3>\n<p>I&#39;ll be working off a modified clone of the link above, which you can find <a href=\"https://github.com/patrickshaughnessy/Flux-Flow-Tutorial\" title=\"link to github repo\">here</a>. Feel free to follow along, or checkout the &quot;final&quot; branch to see the end result.</p>\n<p>To start, I removed a few things from our SwordOfTheNinja template, mostly GraphQL stuff, since we won&#39;t be using it in this project. I&#39;ve also installed the dependencies for the flux flow - <em>events</em> and <em>flux</em> - using jspm.</p>\n<p>A lot of tutorials out there, including Facebook&#39;s own getting started projects, are pretty intense. It&#39;s easy to lose the forest for the trees. So in this example, I&#39;m going to try to break it down as simply as possible while still being informative.</p>\n<p>What I&#39;d like to do is set up a simple input that will display a message on the page when I click the &#39;submit&#39; button. Let&#39;s add those as components and import them into our app controller, because we can (and it&#39;s good for practicing modularization).</p>\n<pre><code><span class=\"hljs-comment\">// AppController.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span> from <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Input</span> from <span class=\"hljs-string\">\"./Input\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Messages</span> from <span class=\"hljs-string\">\"./Messages\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {  }\n  }\n  render(){\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;div className=<span class=\"hljs-string\">\"app\"</span>&gt;\n        &lt;<span class=\"hljs-type\">Input</span> /&gt;\n        &lt;<span class=\"hljs-type\">Messages</span> /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">AppController</span>\n</code></pre><p>and the components:</p>\n<p>Input.js</p>\n<pre><code><span class=\"hljs-comment\">// Input.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span> from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Input</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {  }\n  }\n  render(){\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;form className=<span class=\"hljs-string\">\"input\"</span>&gt;\n        &lt;input <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span></span>=<span class=\"hljs-string\">\"text\"</span> placeholder=<span class=\"hljs-string\">\"Enter a new message\"</span> /&gt;\n        &lt;button <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span></span>=<span class=\"hljs-string\">\"submit\"</span>&gt;<span class=\"hljs-type\">Submit</span>&lt;/button&gt;\n      &lt;/form&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">Input</span>\n</code></pre><p>and Messages.js</p>\n<pre><code><span class=\"hljs-comment\">// Messages.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span> from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Messages</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {  }\n  }\n  render(){\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;div className=<span class=\"hljs-string\">\"messages\"</span>&gt;\n        &lt;h1&gt;<span class=\"hljs-type\">New</span> <span class=\"hljs-type\">Messages</span>:&lt;/h1&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">Messages</span>\n</code></pre><h3 id=\"the-main-event\">The Main Event</h3>\n<p>Ok, now that we have our scaffold ready, let&#39;s set up the flow. One thing to keep in mind is that we want to keep our components &quot;stupid&quot;, meaning we want to keep them stateless as much as possible and handle the business logic of our app in the AppController. We&#39;ll start by adding an onClick listener to our submit button, which we&#39;ll pass in as a prop on our Input component.</p>\n<pre><code><span class=\"hljs-comment\">// AppController.js</span>\n  &lt;Input clickHandler={<span class=\"hljs-keyword\">this</span>.submitMessage.bind(<span class=\"hljs-keyword\">this</span>)} /&gt;\n</code></pre><p>The new message text will be updated in our Input&#39;s state, and passed up to the AppController for processing.</p>\n<pre><code><span class=\"hljs-comment\">// Input.js</span>\nupdateMessageText(e){\n    <span class=\"hljs-keyword\">this</span>.setState({ newMessage: e.target.value })\n}\n\nrender(){\n    let newMessage = <span class=\"hljs-keyword\">this</span>.state.newMessage;\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;form className=<span class=\"hljs-string\">\"input\"</span>&gt;\n        &lt;input onChange={<span class=\"hljs-keyword\">this</span>.updateMessageText.bind(<span class=\"hljs-keyword\">this</span>)} <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span></span>=<span class=\"hljs-string\">\"text\"</span> placeholder=<span class=\"hljs-string\">\"Enter a new message\"</span> /&gt;\n        &lt;button onClick={<span class=\"hljs-keyword\">this</span>.props.clickHandler.bind(<span class=\"hljs-keyword\">this</span>, newMessage)} <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span></span>=<span class=\"hljs-string\">\"submit\"</span>&gt;<span class=\"hljs-type\">Submit</span>&lt;/button&gt;\n      &lt;/form&gt;\n    )\n  }\n}\n</code></pre><p>Now that we have our message text available to the AppController, let&#39;s process the data on submit. The flux flow works as follows:</p>\n<ol>\n<li>The COMPONENT emits an ACTION on user interaction</li>\n<li>The ACTION executes a function in your app&#39;s internal API</li>\n<li>The API sends the request to your server, which then returns a response. The response is then sent as an ACTION from the API</li>\n<li>The server ACTION dispatches a message to your STORE with the response (i.e. data) from the server.</li>\n<li>The STORE processes the data according to the type of message. This usually involves manipulating private variables inside the STORE with the new information.</li>\n<li>The STORE emits a CHANGE event, signalling that the data in the STORE has changed.</li>\n<li>The COMPONENT receives the message that data in the STORE has changed, and re-renders the view accordingly.</li>\n</ol>\n<p>Sounds a bit complicated, but we&#39;ll take it slow. If you&#39;ve ever worked with websockets or Firebase, the principle is very similar here.</p>\n<h4 id=\"1-the-component-emits-an-action\">1) The COMPONENT emits an ACTION</h4>\n<p>Let&#39;s start by adding our submitMessage function to the AppController. Then let&#39;s emit a message ACTION with the newMessage data.</p>\n<pre><code><span class=\"hljs-comment\">// AppController.js</span>\nimport MessageActions <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../actions/MessageActions'</span>;\n\nsubmitMessage(newMessage, <span class=\"hljs-keyword\">event</span>){\n    <span class=\"hljs-keyword\">event</span>.preventDefault();\n    MessageActions.addNewMessage({ text: newMessage });\n}\n</code></pre><h4 id=\"2-the-action-executes-a-function-in-your-api\">2) The ACTION executes a function in your API</h4>\n<p>Now we&#39;ll need to create the MessageActions.js file in a new directory: lib/actions</p>\n<pre><code><span class=\"hljs-comment\">// MessageActions.js</span>\n<span class=\"hljs-keyword\">import</span> API <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../API'</span>;\n\n<span class=\"hljs-keyword\">let</span> MessageActions = {\n  addNewMessage(message){\n    API.addNewMessage(message);\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> MessageActions;\n</code></pre><h4 id=\"3-the-api-sends-the-request-to-your-server-emits-a-server-action-with-the-response\">3) The API sends the request to your server &amp; emits a server ACTION with the response</h4>\n<p>Create an API.js file in lib</p>\n<pre><code><span class=\"hljs-comment\">// API.js</span>\n<span class=\"hljs-keyword\">import</span> {get, post} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'jquery'</span>;\n<span class=\"hljs-keyword\">import</span> ServerActions <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./actions/ServerActions'</span>;\n\n<span class=\"hljs-keyword\">let</span> API = {\n  addNewMessage(message) {\n    post(<span class=\"hljs-string\">'/messages'</span>, message).done(data =&gt; ServerActions.receiveMessages(data));\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> API;\n</code></pre><p>A few things to note here:</p>\n<ul>\n<li>I&#39;m expecting to receive all of my messages from this request to the server. You could totally choose to send back only the new message, or whatever data you like. For this example, I think it&#39;s the easiest to handle in the view.</li>\n<li>I&#39;m not handling any errors from the server response. This is the place to do it (maybe even as an ErrorAction!).</li>\n</ul>\n<p>Let&#39;s take a moment to configure our route while we&#39;re here. I&#39;ll just stick it in the index route for simplicity, but feel free to put it wherever you like. Also, I&#39;m just going to simulate a database here as a local variable, messages. You&#39;ll want to hook up to your database here (e.g. create a new Message document and save it to your MongoDB).</p>\n<pre><code><span class=\"hljs-comment\">// routes/index.js</span>\nimport express from <span class=\"hljs-string\">'express'</span><span class=\"hljs-comment\">;</span>\nconst router = express.Router()<span class=\"hljs-comment\">;</span>\n\nlet messages = []<span class=\"hljs-comment\">;</span>\n\nrouter.post(<span class=\"hljs-string\">'/messages'</span>, (req, res) =&gt; {\n  messages.push(req.body.text)<span class=\"hljs-comment\">;</span>\n  res.send(messages)<span class=\"hljs-comment\">;</span>\n})\n\nexport <span class=\"hljs-keyword\">default</span> router<span class=\"hljs-comment\">;</span>\n</code></pre><p>Now that we&#39;ve got all of our messages coming back from the server, our API will emit the server ACTION.</p>\n<h4 id=\"4-the-server-action-dispatches-a-message-to-the-store\">4) The server ACTION dispatches a message to the STORE</h4>\n<p>Back in the actions folder, make a new file, ServerActions.js. Inside our server actions, we&#39;ll dispatch the messages we received from the API to our STORE via the App Dispatcher.</p>\n<pre><code><span class=\"hljs-comment\">// ServerActions.js</span>\n<span class=\"hljs-keyword\">import</span> AppDispatcher <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../AppDispatcher'</span>;\n\n<span class=\"hljs-keyword\">let</span> ServerActions = {\n  receiveMessages(messages) {\n    AppDispatcher.dispatch({\n      actionType: <span class=\"hljs-string\">'RECEIVE_MESSAGES'</span>,\n      messages\n    });\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> ServerActions;\n</code></pre><p>The App Dispatcher is basically like your internal flux router. And it&#39;s super simple to setup.</p>\n<pre><code><span class=\"hljs-comment\">// lib/AppDispatcher.js</span>\n<span class=\"hljs-keyword\">import</span> Flux <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'flux'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> Flux.Dispatcher();\n</code></pre><p>Shweet!</p>\n<h4 id=\"5-the-store-processes-the-data\">5) The STORE processes the data</h4>\n<p>Let&#39;s set up our store so the AppDispatcher has somewhere to send this data. Make a new directory lib/stores with a MessageStore.js file. Inside we&#39;ll create the MessageStore class which extends the EventEmitter from the &#39;events&#39; library we installed at the beginning.</p>\n<p>First we&#39;ll register the action type with the AppDispatcher. When the AppDispatcher receives this particular message of &#39;RECEIVE_MESSAGES&#39;, we want to set our private variable _messages to the new array of messages coming back from the server. This data is attached to the action that we dispatched from ServerActions. Finally, we&#39;ll want to emit a &#39;CHANGE&#39; event, notifying all interested components that data in our Message Store has changed.</p>\n<pre><code><span class=\"hljs-comment\">// stores/MessageStore.js</span>\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-type\">EventEmitter</span>} from <span class=\"hljs-symbol\">'event</span>s';\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">AppDispatcher</span> from '../<span class=\"hljs-type\">AppDispatcher</span>';\n\nlet _messages = [];\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageStore</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">EventEmitter</span> </span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n\n    <span class=\"hljs-type\">AppDispatcher</span>.register(action =&gt; {\n      switch (action.actionType) {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-symbol\">'RECEIVE_MESSAGE</span>S':\n          _messages = action.messages;\n          <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-symbol\">'CHANG</span>E');\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    });\n  }\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MessageStore</span>();\n</code></pre><h4 id=\"6-the-store-emits-a-change-event\">6) The STORE emits a CHANGE event</h4>\n<p>Before we move on from the store, let&#39;s anticipate the next step. We&#39;ll want our component to listen for changes to data in our store. So let&#39;s set up some listener functions, as well as a way for our component to access the private variable, messages.</p>\n<pre><code><span class=\"hljs-comment\">// MessageStore.js</span>\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-type\">EventEmitter</span>} from <span class=\"hljs-symbol\">'event</span>s';\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">AppDispatcher</span> from '../<span class=\"hljs-type\">AppDispatcher</span>';\n\nlet _messages = [];\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MessageStore</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">EventEmitter</span> </span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n\n    <span class=\"hljs-type\">AppDispatcher</span>.register(action =&gt; {\n      switch (action.actionType) {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-symbol\">'RECEIVE_MESSAGE</span>S':\n          _messages = action.messages;\n          <span class=\"hljs-keyword\">this</span>.emit(<span class=\"hljs-symbol\">'CHANG</span>E');\n          <span class=\"hljs-keyword\">break</span>;\n      }\n    });\n  }\n\n  getAllMessages() {\n    <span class=\"hljs-keyword\">return</span> _messages;\n  }\n\n  startListening(cb){\n    <span class=\"hljs-keyword\">this</span>.on(<span class=\"hljs-symbol\">'CHANG</span>E', cb);\n  }\n\n  stopListening(cb){\n    <span class=\"hljs-keyword\">this</span>.removeListener(<span class=\"hljs-symbol\">'CHANG</span>E', cb);\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MessageStore</span>();\n</code></pre><h4 id=\"7-the-component-receives-the-message-and-re-renders-the-view\">7) The COMPONENT receives the message and re-renders the view</h4>\n<p>Lastly, we&#39;ll head back to AppController and register our change listeners and data fetching functions to update the view whenever we get a new message. I&#39;ll use a private function, _getAppState here to handle state changes and data fetching. This is useful because we can simply add calls to our stores as we add data requirements to our app.</p>\n<pre><code><span class=\"hljs-comment\">// AppController.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span> from <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Input</span> from <span class=\"hljs-string\">\"./Input\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Messages</span> from <span class=\"hljs-string\">\"./Messages\"</span>;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">MessageActions</span> from '../actions/<span class=\"hljs-type\">MessageActions</span>';\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">MessageStore</span> from '../stores/<span class=\"hljs-type\">MessageStore</span>';\n\nlet _getAppState = () =&gt; {\n  <span class=\"hljs-keyword\">return</span> {\n    messages: <span class=\"hljs-type\">MessageStore</span>.getAllMessages()\n  }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = _getAppState();\n    <span class=\"hljs-keyword\">this</span>._onChange = <span class=\"hljs-keyword\">this</span>._onChange.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n\n\n  componentDidMount(){\n    <span class=\"hljs-type\">MessageStore</span>.startListening(<span class=\"hljs-keyword\">this</span>._onChange);\n  }\n\n  componentWillUnmount(){\n    <span class=\"hljs-type\">MessageStore</span>.stopListening(<span class=\"hljs-keyword\">this</span>._onChange);\n  }\n\n  _onChange() {\n    <span class=\"hljs-keyword\">this</span>.setState(_getAppState());\n  }\n\n  submitMessage(newMessage, event){\n    event.preventDefault();\n    <span class=\"hljs-type\">MessageActions</span>.addNewMessage({ text: newMessage });\n  }\n\n  render(){\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;div className=<span class=\"hljs-string\">\"app\"</span>&gt;\n        &lt;<span class=\"hljs-type\">Input</span> clickHandler={<span class=\"hljs-keyword\">this</span>.submitMessage.bind(<span class=\"hljs-keyword\">this</span>)} /&gt;\n        &lt;<span class=\"hljs-type\">Messages</span> messages={<span class=\"hljs-keyword\">this</span>.state.messages} /&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">AppController</span>\n</code></pre><p>When the component mounts and unmounts, we&#39;ll add and remove the change listener. When we receive new data about messages, we&#39;ll update the state of the application to reflect the new data. Finally, we&#39;ll pass in the message data to our Messages component.</p>\n<p>Inside the Messages component we can display new messages by mapping over our array, rendering each as an &lt;li&gt; component. I set the key attribute to the index of the element, but in practice you should consider setting this to the message ID.</p>\n<pre><code><span class=\"hljs-comment\">// Messages.js</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">React</span> from <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Messages</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span></span>{\n  constructor(props){\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {  }\n  }\n  render(){\n    let messages = <span class=\"hljs-keyword\">this</span>.props.messages.map((message, i) =&gt; {\n      <span class=\"hljs-keyword\">return</span> &lt;li key={i}&gt;{message}&lt;/li&gt;\n    })\n\n    <span class=\"hljs-keyword\">return</span>(\n      &lt;div className=<span class=\"hljs-string\">\"messages\"</span>&gt;\n        &lt;h1&gt;<span class=\"hljs-type\">New</span> <span class=\"hljs-type\">Messages</span>:&lt;/h1&gt;\n        &lt;ul&gt;\n          {messages}\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">Messages</span>\n</code></pre><p>And that&#39;s about it! Spin up that server, add some new messages and watch them appear to your heart&#39;s content.</p>\n<h3 id=\"final-thoughts\">Final Thoughts</h3>\n<p>The first time I saw flux, I was pretty lost. Even after I&#39;d set it up on a few apps, I still didn&#39;t see the value in writing ALL that code just for a simple API call. I think the key is really understanding this idea of unidirectional data flow. Angular is great for a lot of things, and it&#39;s famous for its two-way data binding.</p>\n<p>But when your app starts growing and you start working with a lot of data, keeping track of it in both the view and the controller can become cumbersome. With the flux flow, you always know where your data is coming from and can more easily regulate which components get to know about it. I think this helps to both reduce bugs and headaches as your app grows, allowing you to spend more time working up that next rad feature.</p>\n<p>Was this helpful? Let me know on twitter <a href=\"https://twitter.com/pattshaughnessy\" title=\"Twitter Link\">@pattshaughnessy</a>!</p>\n<hr>\n"}]